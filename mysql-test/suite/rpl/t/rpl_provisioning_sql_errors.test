# MDEV-7502 Automatic provisioning of slave
# Tested functionality of LOAD DATA FROM MASTER - manipulation with data not
# yet present on slave

--source include/rpl_provisioning_init.inc

# Create databases and tables on master + fill them with data
--connection master
RESET MASTER;

CREATE TABLE test.t1 (a int, b int, PRIMARY KEY (a));
INSERT INTO test.t1 VALUES (1, 1), (2, 2);

# Start provisioning without sending any data - not even database / table structures
SET GLOBAL debug_dbug="+d,provisioning_wait";
--connection slave
LOAD DATA FROM MASTER;

# Now modify data in table on master while table does not exist on slave
--connection master
UPDATE test.t1 SET b = 2 WHERE a = 1;
DELETE FROM test.t1 WHERE a= 2;
INSERT INTO test.t1 VALUES (3, 3);

# Create table on slave and modify data on master
--connection slave
CREATE DATABASE test;
CREATE TABLE test.t1 (a int, b int, PRIMARY KEY (a));
--connection master
UPDATE test.t1 SET b = 3 WHERE a = 1;
DELETE FROM test.t1 WHERE a= 3;
INSERT INTO test.t1 VALUES (4, 4);

# Now clean up manually created data on slave and start provisioning
--connection slave
DROP DATABASE test;
--connection master
SET GLOBAL debug_dbug="-d,provisioning_wait";

# Provisioning is completed after sql thread was shut down
--connection slave
--source include/wait_for_slave_sql_to_stop.inc

SELECT * FROM test.t1;

# Cleanup
--connection master
DROP TABLE test.t1;
SET GLOBAL debug_dbug="";

--connection slave
DROP TABLE test.t1;
SET GLOBAL debug_dbug="";

--let $rpl_only_running_threads= 1
--source include/rpl_end.inc
