# MDEV-7502 Automatic provisioning of slave
# Tested functionality of LOAD DATA FROM MASTER - error detection

--source include/rpl_provisioning_init.inc

#
# Attempt to start provisioning with slave_run_triggers_for_rbr enabled
#
--connection slave
SET GLOBAL slave_run_triggers_for_rbr=YES;
--error 1980
LOAD DATA FROM MASTER;

# Cleanup after test case
SET GLOBAL slave_run_triggers_for_rbr=NO;

#
# Attempt to start provisioning while SQL thread is running
#
START SLAVE SQL_THREAD;
--error 1198
LOAD DATA FROM MASTER;

# Cleanup after test case
--source include/stop_slave_sql.inc

#
# Attempt to start provisioning while IO thread is running
#
START SLAVE IO_THREAD;
--error 1198
LOAD DATA FROM MASTER;

# Cleanup after test case
--source include/stop_slave_io.inc

#
# Attempt to provision table without primary key
#
--connection master
CREATE TABLE test.t1 (a int);
INSERT INTO test.t1 VALUES (1), (2), (3), (4), (5);

--connection slave
call mtr.add_suppression("Slave I/O: Provisioning failed with error code 1979 and message: .Table does not contain primary key. while processing `test`.`t1`, Internal MariaDB error code: 1979");
--source include/load_data_from_master.inc

--let $show_slave_io_error= 1
--let $slave_io_errno= 1979
--source include/wait_for_slave_io_error.inc
RESET SLAVE;

# Cleanup after test case
--connection master
DROP TABLE test.t1;
--connection slave
# Creation of database `test` depends purely on timing and it has nothing to do with this test case
--disable_warnings
DROP DATABASE IF EXISTS test;
--enable_warnings

#
# Disconnect during provisioning
#
--connection slave
SET GLOBAL debug_dbug="+d,FORCE_SLAVE_TO_RECONNECT_DUMP";
call mtr.add_suppression("Slave I/O: Slave disconnected during provisioning, drop already provisioned databases from slave and try again, Internal MariaDB error code: 1981");
LOAD DATA FROM MASTER;

--let $show_slave_io_error= 1
--let $slave_io_errno= 1981
--source include/wait_for_slave_io_error.inc
--source include/stop_slave.inc
RESET SLAVE;

# Cleanup after test case
--connection slave
SET GLOBAL debug_dbug="-d,FORCE_SLAVE_TO_RECONNECT_DUMP";
# Creation of database `test` depends purely on timing and it has nothing to do with this test case
--disable_warnings
DROP DATABASE IF EXISTS test;
--enable_warnings

#
# START SLAVE command during provisioning
#
--connection master
SET GLOBAL debug_dbug="+d,provisioning_wait";

--connection slave
--source include/load_data_from_master.inc

# START SLAVE fails with error
--error 1982
START SLAVE;

# Wait for provisioning to end
--connection master
SET GLOBAL debug_dbug="-d,provisioning_wait";

# Now START SLAVE will succeed
--connection slave
--source include/rpl_provisioning_wait_to_stop.inc
START SLAVE;

# Cleanup after test case
--connection slave
--source include/stop_slave.inc
RESET SLAVE;
# Creation of database `test` depends purely on timing and it has nothing to do with this test case
--disable_warnings
DROP DATABASE IF EXISTS test;
--enable_warnings

#
# DDL on master during provisioning
#
--connection master
SET GLOBAL debug_dbug="+d,provisioning_wait";

--connection slave
--source include/load_data_from_master.inc

--connection master
CREATE TABLE test.t2 (a int, PRIMARY KEY (a));

# Expecting slave error
--connection slave
--let $slave_sql_errno= 1983
--source include/wait_for_slave_sql_error.inc

# Let master finish too
--connection master
SET GLOBAL debug_dbug="-d,provisioning_wait";

# Cleanup after test case
--connection slave
--source include/wait_for_slave_io_to_stop.inc
RESET SLAVE;
# Creation of database `test` depends purely on timing and it has nothing to do with this test case
--disable_warnings
DROP DATABASE IF EXISTS test;
--enable_warnings
--connection master
DROP TABLE test.t2;

#
# Another test case
#

# ...

--source include/rpl_provisioning_end.inc
